\newpage
\vspace*{3.5cm}
\begin{center}
\begin{minipage}{12.5cm}
\section*{Abstract}
Today, GPUs are getting used various fields for an increasing number of diverse purposes.
One of the parts which enable this development are compilers, but so far, the compilers for GPUs have a shortcoming when it comes to optimizations.
At many points a compiler uses heuristics to guess how code will behave at runtime.
If real runtime information are provided to the compiler, it can optimize better and more aggressively as the chance of a misjudgment are lower.

On CPUs, collecting runtime data and providing it to the compiler is called profile-guided optimizations (PGO).
These optimizations are common on CPUs, but they do not yet exist for GPU programs.
While there exist many tools that assist with profiling on GPUs, very few of them provide insight into what happens inside a shader.

This work leverages profile-guided optimizations on GPUs with a focus on collecting profiling information.

As a first part, the basic block counters from LLVM are adjusted to work with GPUs.
They indicate if there exist basic blocks which are never executed.
Up to \SI{30}{\percent} of blocks are unused in some games and can be removed by the compiler for testing purposes.
Analyzing the amount of allocated registers shows that removing unused code does not have a great effect on register usage.

We test five games with LLVM's PGO with basic block counters, leading to performance changes of at most \SI{1}{\percent}.
Some games get faster, some get slower.
A sample shader which implements a switch-case based virtual machine gets more than \SI{20}{\percent} faster by using PGO and removing unused basic blocks.
The overhead of counter instrumentation ranges from \SI{0}{\percent} to \SI{43}{\percent}, averaging at \SI{16}{\percent}.

Apart from execution counters, uniformity of branches and variables is an interesting property on graphics cards.
We implement LLVM passes to log the uniformity of branches and variables.
The collected data about uniform variables and register usage is shown in multiple diagrams, visualizing the runtime behavior of shaders.

%\pagenumbering{arabic}\setcounter{page}{1}
%\begin{abstract}
\end{minipage}
\end{center}

%\newpage
%\vspace*{3.5cm}
%\begin{center}
%\begin{minipage}{12.5cm}

%\section*{Abstrakt}

%Abstrakt deutsch
%\end{minipage}
%\end{center}
