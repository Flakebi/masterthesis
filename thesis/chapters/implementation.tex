\clearpage
\bigsection{Implementation}
The implementation consists of several steps. First, we have to insert instrumentation instructions. This happens inside the LLVM compiler. LLVM already has the ability to emit instrumentation instructions, it only needs to be activated. The activation can be accomplished in LLPC with a few lines of code. The next step is loading the compiled binary onto the GPU, which needs to be adjusted to work. Our changes at this part are summarized in \cref{sub:loading}. After loading a shader it is run. This part is unmodified by our work. When a shader pipeline is destroyed, the driver fetches the collected information and writes them to disk. This part is explained in detail in \cref{sub:save}. The next compilation of a profiled shader can then incorporate the collected information, which is described in \cref{sub:load}.

\subsection{Compiling Shaders}
\label{sub:compiling}
The compilation of shaders in LLPC needs to be adjusted slightly to also generate profiling instrumentation. In detail, we need to set the PGO options of the LLVM \texttt{PassManagerBuilder}. One option that we activate is the use of atomic operations for counters. The execution of a shader on a GPU is highly parallel, so we expect that multiple shaders will write to the same counter simultaneously. Using atomic operations ensures that no executions are lost in the counter. LLVM generates an ELF file with additional data and code sections that contain e.g. basic block counters and the registered destructor to write the data to disk. We cannot directly use the destructor generated by LLVM because code on the GPU does not have access to the file system on the host. Our solution is described in \cref{sub:save}.

\subsection{Loading Shaders}
\label{sub:loading}
In the AMDVLK Vulkan driver, PAL is responsible for loading the shader ELF files, copying them to GPU memory and running them. The previous ELF support of PAL was limited as it only extracted the \texttt{.text} and \texttt{.data} section (code and data) and uploaded them. This is insufficient for PGO instrumentation, we also need to load the additional data sections for counters and other data. As part of this work, we implemented loading all sections in the ELF which are marked with write or execution flags.

The code in the compiled object file contains references to the counters in the data section. As the addresses are not yet known at compile-time, LLVM adds relocation entries for them as described in \cref{sub:elf}. We implemented applying these relocations in PAL. The steps in PAL to load a shader are:
\begin{enumerate}
	\item Allocate memory for all sections on the GPU so we know their final addresses
	\item Copy sections to the allocated GPU memory by mapping the GPU memory to the CPU
	\item Iterate through all relocation sections and perform the relocations
\end{enumerate}
When performing the relocations, we read from the loaded ELF file on the CPU and write to the GPU mapped memory. Reading from GPU mapped memory would mean we have to wait until the data arrives through the PCIe bus, which takes longer than reading from CPU memory. On the other hand, writing is fine because we do not have to wait until data is actually written, we can just continue thus hiding the latency.

PAL's ELF parser contained a bug so it only supported \texttt{sh\_link} and \texttt{sh\_info} references to already loaded sections. This bug was fixed as part of this thesis.

%The string table for a given symbol table is available in the table's section header in \texttt{sh\_link}.

\subsection{Fetching and Storing Data}
\label{sub:save}
As described in \cref{sub:save-design}, we cannot create the data files from inside the shader. Instead, we have to use the driver to write the files.

Most parts of the file writing code of LLVM is inside a library which gets statically linked when PGO instrumentation is enabled. We decided to link that library into PAL, so the driver can access the file writing code. The needed information to write a file are the addresses and sizes of the PGO related ELF sections. In PAL we can read this information from the pipeline ELF file. We map the sections from the GPU memory on the CPU, write their addresses into global variables and call the LLVM PGO file dump function.

% TODO
Raw file format contains raw pointers. Some of the have to be changed in the driver.
Replace address in GPU virtual memory with address to CPU virtual memory which maps to the GPU memory.
Otherwise \texttt{llvm-profdata} complains about malformed input when reading the file.

\subsection{Loading Profile Data}
\label{sub:load}