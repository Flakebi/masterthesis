\clearpage
\bigsection{Design}
Where to integrate that instrumentation: In the llpc patcher

How does it work with pal?
How do we bring the information back to the cpu and write them to disk?

Implementation:

How to call it: command line option or environment variable (with shader hash?)

\subsection{Workflow}
\label{sub:workflow}
% TODO
\Gls{pgo} is a common technique for applications running on CPUs.
Developers are already used to the way PGO is applied.
When using a compiler that builds upon the LLVM framework, the workflow is the following:
\begin{enumerate}
	\item The application is compiled with profiling instrumentation
	\item The application is run $n$ times and produces an output file on each run
	\item The $n$ files are merged into a single file which contains all profiling information
	\item The application is compiled again and optimized using the data from the generated file
\end{enumerate}
As the AMD Vulkan driver is based on LLVM and developers already know this workflow,
it suggests itself to use the same workflow for PGO on GPUs.

Cannot directly set command line arguments when invoking compiler because it works through the vulkan API.
To make it simple, set an environment variable \texttt{AMDVLK\_PROFILE\_INSTR\_GEN} to the path using \texttt{\%m} for LLVM unique id and \texttt{\%i} for pipeline id.
Setting the variable activates PGO instrumentation in LLVM and writes the data to files.

Similarly, in the third step, after merging the files, set \texttt{AMDVLK\_PROFILE\_INSTR\_GEN} and the driver searches for data files and supplies them to LLVM. Also use \texttt{\%i} for pipeline id.

\subsection{Storing Data}
\label{sub:save-design}
% TODO
LLVM generates code for writing the collected data into a file and calls this code from a destructor.
Destructors are a list of functions which are called when an application exits.
The code creates a file containing all the profile data, consisting of counters, metadata and possible variable values if value profiling is enabled.
GPUs do not support the destructor list and they are unable to access the file system of the host.
So directly creating and writing the result from the GPU is impossible.

We try to reuse the file writing code from LLVM but inside the driver instead of inside the shader.
The driver has access to all the data generated by the shader, it can map the memory to the CPU and read it.