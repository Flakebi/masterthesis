\clearpage
\bigsection{Design}
Where to integrate that instrumentation: In the llpc patcher

How does it work with pal?
How do we bring the information back to the cpu and write them to disk?

Implementation:

How to call it: command line option or environment variable (with shader hash?)

\subsection{Workflow}
\label{sub:workflow}
\Gls{pgo} is a common technique for applications running on CPUs.
Developers are already used to the way PGO is applied.
When using a compiler that builds upon the LLVM framework, the workflow is the following:
\begin{enumerate}
	\item The application is compiled with profiling instrumentation
	\item The application is run $n$ times and produces an output file on each run
	\item The $n$ files are merged into a single file which contains all profiling information
	\item The application is compiled again and optimized using the data from the generated file
\end{enumerate}
As the AMD Vulkan driver is based on LLVM and developers already know this workflow, it suggests itself to use the same workflow for PGO on GPUs.
When using PGO with \texttt{clang}, we use command line arguments to tell LLVM which options we want to use. When invoking the compiler through the Vulkan API, we cannot use command line arguments.
To keep the usage and implementation of options simple, we use environment variables to pass filenames and other options.

\subsection{Storing Data}
\label{sub:save-design}
% TODO
LLVM generates code for writing the collected data into a file and calls this code from a destructor.
Destructors are a list of functions which are called when an application exits.
The code creates a file containing all the profile data, consisting of counters, metadata and possible variable values if value profiling is enabled.
GPUs do not support the destructor list and they are unable to access the file system of the host.
So directly creating and writing the result from the GPU is impossible.

We try to reuse the file writing code from LLVM but inside the driver instead of inside the shader.
The driver has access to all the data generated by the shader, it can map the memory to the CPU and read it.

\subsection{Uniform Variables}
\label{sub:uniformity}
% TODO Explain per-wave counters before
% TODO
The first idea on how to detect uniform branches is simple. If we count the executed basic blocks per SIMD unit and we have a branch where either an if-block or an else-block gets executed, we can compute how often both blocks are executed so we know how uniform the condition is.
However, this technique does not work if we have no else-block. The uniformity of other variables, e.g. memory addresses may also be interesting, so we decided to implement a generic analysis that finds out how often a variable is uniform.
